/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const MetaSolverStrategyTerminals = {
    WS: /\s+/,
    NAME: /[a-z][\w_]*/,
    ID: /[_a-zA-Z][\w_]*/,
    INT: /[0-9]+/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type MetaSolverStrategyTerminalNames = keyof typeof MetaSolverStrategyTerminals;

export type MetaSolverStrategyKeywordNames =
    | "!="
    | "("
    | ")"
    | ","
    | "."
    | ":"
    | "<"
    | "<="
    | "="
    | "=="
    | ">"
    | ">="
    | "[]"
    | "else"
    | "false"
    | "foreach"
    | "if"
    | "in"
    | "solve"
    | "true";

export type MetaSolverStrategyTokenNames = MetaSolverStrategyTerminalNames | MetaSolverStrategyKeywordNames;

export type ComparisonOperator = '!=' | '<' | '<=' | '==' | '>' | '>=';

export function isComparisonOperator(item: unknown): item is ComparisonOperator {
    return item === '<' || item === '<=' || item === '>' || item === '>=' || item === '==' || item === '!=';
}

export type Solve = If | Solver;

export const Solve = 'Solve';

export function isSolve(item: unknown): item is Solve {
    return reflection.isInstance(item, Solve);
}

export type SolveMany = Foreach;

export const SolveMany = 'SolveMany';

export function isSolveMany(item: unknown): item is SolveMany {
    return reflection.isInstance(item, SolveMany);
}

export interface BoolExpression extends langium.AstNode {
    readonly $container: Else | If;
    readonly $type: 'BoolExpression';
    lhs?: Expression;
    operator?: ComparisonOperator;
    rhs?: Expression;
}

export const BoolExpression = 'BoolExpression';

export function isBoolExpression(item: unknown): item is BoolExpression {
    return reflection.isInstance(item, BoolExpression);
}

export interface Expression extends langium.AstNode {
    readonly $container: BoolExpression;
    readonly $type: 'Expression';
    attribute?: ProblemAttribute;
    int?: number;
    problemName?: langium.Reference<ProblemName>;
    string?: string;
}

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export interface Foreach extends langium.AstNode {
    readonly $container: SolveProblem;
    readonly $type: 'Foreach';
    collection: langium.Reference<ProblemArrayName>;
    solve: Solve;
    variable: ProblemName;
}

export const Foreach = 'Foreach';

export function isForeach(item: unknown): item is Foreach {
    return reflection.isInstance(item, Foreach);
}

export interface If extends langium.AstNode {
    readonly $type: 'Else' | 'If';
    condition: Array<BoolExpression>;
    solve: Array<Solve>;
}

export const If = 'If';

export function isIf(item: unknown): item is If {
    return reflection.isInstance(item, If);
}

export interface ProblemArrayName extends langium.AstNode {
    readonly $container: SolveProblem;
    readonly $type: 'ProblemArrayName';
    name: string;
}

export const ProblemArrayName = 'ProblemArrayName';

export function isProblemArrayName(item: unknown): item is ProblemArrayName {
    return reflection.isInstance(item, ProblemArrayName);
}

export interface ProblemAttribute extends langium.AstNode {
    readonly $container: Expression;
    readonly $type: 'ProblemAttribute';
    name: string;
}

export const ProblemAttribute = 'ProblemAttribute';

export function isProblemAttribute(item: unknown): item is ProblemAttribute {
    return reflection.isInstance(item, ProblemAttribute);
}

export interface ProblemName extends langium.AstNode {
    readonly $container: Foreach | SolveProblem;
    readonly $type: 'ProblemName';
    name: string;
}

export const ProblemName = 'ProblemName';

export function isProblemName(item: unknown): item is ProblemName {
    return reflection.isInstance(item, ProblemName);
}

export interface ProblemType extends langium.AstNode {
    readonly $container: ProblemTypes | SolveProblem;
    readonly $type: 'ProblemType';
    problemType: string;
}

export const ProblemType = 'ProblemType';

export function isProblemType(item: unknown): item is ProblemType {
    return reflection.isInstance(item, ProblemType);
}

export interface ProblemTypes extends langium.AstNode {
    readonly $container: SolveProblem;
    readonly $type: 'ProblemTypes';
    problemType: ProblemType;
}

export const ProblemTypes = 'ProblemTypes';

export function isProblemTypes(item: unknown): item is ProblemTypes {
    return reflection.isInstance(item, ProblemTypes);
}

export interface SolveProblem extends langium.AstNode {
    readonly $container: SubRoutines;
    readonly $type: 'SolveProblem';
    problemName: ProblemArrayName | ProblemName;
    problemType?: ProblemType;
    problemTypes?: ProblemTypes;
    solve: Solve | SolveMany;
}

export const SolveProblem = 'SolveProblem';

export function isSolveProblem(item: unknown): item is SolveProblem {
    return reflection.isInstance(item, SolveProblem);
}

export interface Solver extends langium.AstNode {
    readonly $container: Else | Foreach | If | SolveProblem;
    readonly $type: 'Solver';
    problemName: langium.Reference<ProblemName>;
    settings: Array<SolverSetting>;
    solverId: SolverID;
    subRoutines?: SubRoutines;
}

export const Solver = 'Solver';

export function isSolver(item: unknown): item is Solver {
    return reflection.isInstance(item, Solver);
}

export interface SolverID extends langium.AstNode {
    readonly $container: Solver;
    readonly $type: 'SolverID';
    solverId: string;
}

export const SolverID = 'SolverID';

export function isSolverID(item: unknown): item is SolverID {
    return reflection.isInstance(item, SolverID);
}

export interface SolverSetting extends langium.AstNode {
    readonly $container: Solver;
    readonly $type: 'SolverSetting';
    settingName: string;
    settingValue: string;
}

export const SolverSetting = 'SolverSetting';

export function isSolverSetting(item: unknown): item is SolverSetting {
    return reflection.isInstance(item, SolverSetting);
}

export interface SubRoutines extends langium.AstNode {
    readonly $container: Solver;
    readonly $type: 'SubRoutines';
    subRoutine: Array<SolveProblem>;
}

export const SubRoutines = 'SubRoutines';

export function isSubRoutines(item: unknown): item is SubRoutines {
    return reflection.isInstance(item, SubRoutines);
}

export interface Else extends If {
    readonly $type: 'Else';
    condition: Array<BoolExpression>;
    solve: Array<Solve>;
}

export const Else = 'Else';

export function isElse(item: unknown): item is Else {
    return reflection.isInstance(item, Else);
}

export type MetaSolverStrategyAstType = {
    BoolExpression: BoolExpression
    Else: Else
    Expression: Expression
    Foreach: Foreach
    If: If
    ProblemArrayName: ProblemArrayName
    ProblemAttribute: ProblemAttribute
    ProblemName: ProblemName
    ProblemType: ProblemType
    ProblemTypes: ProblemTypes
    Solve: Solve
    SolveMany: SolveMany
    SolveProblem: SolveProblem
    Solver: Solver
    SolverID: SolverID
    SolverSetting: SolverSetting
    SubRoutines: SubRoutines
}

export class MetaSolverStrategyAstReflection extends langium.AbstractAstReflection {

    getAllTypes(): string[] {
        return [BoolExpression, Else, Expression, Foreach, If, ProblemArrayName, ProblemAttribute, ProblemName, ProblemType, ProblemTypes, Solve, SolveMany, SolveProblem, Solver, SolverID, SolverSetting, SubRoutines];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Else: {
                return this.isSubtype(If, supertype);
            }
            case Foreach: {
                return this.isSubtype(SolveMany, supertype);
            }
            case If:
            case Solver: {
                return this.isSubtype(Solve, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: langium.ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Expression:problemName':
            case 'Solver:problemName': {
                return ProblemName;
            }
            case 'Foreach:collection': {
                return ProblemArrayName;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): langium.TypeMetaData {
        switch (type) {
            case BoolExpression: {
                return {
                    name: BoolExpression,
                    properties: [
                        { name: 'lhs' },
                        { name: 'operator' },
                        { name: 'rhs' }
                    ]
                };
            }
            case Expression: {
                return {
                    name: Expression,
                    properties: [
                        { name: 'attribute' },
                        { name: 'int' },
                        { name: 'problemName' },
                        { name: 'string' }
                    ]
                };
            }
            case Foreach: {
                return {
                    name: Foreach,
                    properties: [
                        { name: 'collection' },
                        { name: 'solve' },
                        { name: 'variable' }
                    ]
                };
            }
            case If: {
                return {
                    name: If,
                    properties: [
                        { name: 'condition', defaultValue: [] },
                        { name: 'solve', defaultValue: [] }
                    ]
                };
            }
            case ProblemArrayName: {
                return {
                    name: ProblemArrayName,
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case ProblemAttribute: {
                return {
                    name: ProblemAttribute,
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case ProblemName: {
                return {
                    name: ProblemName,
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case ProblemType: {
                return {
                    name: ProblemType,
                    properties: [
                        { name: 'problemType' }
                    ]
                };
            }
            case ProblemTypes: {
                return {
                    name: ProblemTypes,
                    properties: [
                        { name: 'problemType' }
                    ]
                };
            }
            case SolveProblem: {
                return {
                    name: SolveProblem,
                    properties: [
                        { name: 'problemName' },
                        { name: 'problemType' },
                        { name: 'problemTypes' },
                        { name: 'solve' }
                    ]
                };
            }
            case Solver: {
                return {
                    name: Solver,
                    properties: [
                        { name: 'problemName' },
                        { name: 'settings', defaultValue: [] },
                        { name: 'solverId' },
                        { name: 'subRoutines' }
                    ]
                };
            }
            case SolverID: {
                return {
                    name: SolverID,
                    properties: [
                        { name: 'solverId' }
                    ]
                };
            }
            case SolverSetting: {
                return {
                    name: SolverSetting,
                    properties: [
                        { name: 'settingName' },
                        { name: 'settingValue' }
                    ]
                };
            }
            case SubRoutines: {
                return {
                    name: SubRoutines,
                    properties: [
                        { name: 'subRoutine', defaultValue: [] }
                    ]
                };
            }
            case Else: {
                return {
                    name: Else,
                    properties: [
                        { name: 'condition', defaultValue: [] },
                        { name: 'solve', defaultValue: [] }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new MetaSolverStrategyAstReflection();
